diff --git a/config.c b/config.c
index e967949..a73e2f7 100644
--- a/config.c
+++ b/config.c
@@ -65,6 +65,9 @@ void init_default_config(struct mako_config *config) {
 
 	config->anchor =
 		ZWLR_LAYER_SURFACE_V1_ANCHOR_TOP | ZWLR_LAYER_SURFACE_V1_ANCHOR_RIGHT;
+
+	config->paths = calloc(16, sizeof(char*));
+	memset(config->paths, 0, 16 * sizeof(char*));
 }
 
 void finish_config(struct mako_config *config) {
@@ -76,6 +79,11 @@ void finish_config(struct mako_config *config) {
 	finish_style(&config->superstyle);
 	finish_style(&config->hidden_style);
 	free(config->output);
+
+	for (int i = 0; i < 16; i++) {
+		if (config->paths[i] != NULL) free(config->paths[i]);
+	}
+	free(config->paths);
 }
 
 void init_default_style(struct mako_style *style) {
@@ -428,6 +436,27 @@ static bool apply_config_option(struct mako_config *config, const char *name,
 			return false;
 		}
 		return true;
+	} else if (strcmp(name, "include") == 0) {
+		char *config_path = NULL;
+		if (value[0] == '/') {
+			config_path = strdup(value);
+		} else {
+			char *config_dirname = NULL;
+			for (int i = 0; i < 16; i++) {
+				if (config->paths[i] != NULL) {
+					config_dirname = dirname(config->paths[i]);
+					break;
+				}
+			}
+			if (config_dirname == NULL) {
+				return false;
+			}
+			config_path = calloc(strlen(config_dirname) + strlen(value) + 1, sizeof(char));
+			strcpy(config_path, config_dirname);
+			strcat(config_path, "/");
+			strcat(config_path, value);
+		}
+		return load_config_file(config, config_path) == 0;
 	}
 
 	return false;
@@ -563,6 +592,23 @@ int load_config_file(struct mako_config *config, char *config_arg) {
 	}
 	const char *base = basename(path);
 
+	int path_idx = 0;
+	for (int i = 0; i < 16; i++) {
+		if (config->paths[i] == NULL) {
+			path_idx = i;
+			config->paths[i] = path;
+			break;
+		} else if (strcmp(config->paths[i], path) == 0) {
+			fprintf(stderr, "Config %s already loaded\n", path);
+			free(path);
+			return -1;
+		} else if (i == 15) {
+			fprintf(stderr, "Maximum configs loaded\n");
+			free(path);
+			return -1;
+		}
+	}
+
 	int ret = 0;
 	int lineno = 0;
 	char *line = NULL;
@@ -640,7 +686,10 @@ int load_config_file(struct mako_config *config, char *config_arg) {
 	free(section);
 	free(line);
 	fclose(f);
-	free(path);
+	if (ret == -1) {
+		free(config->paths[path_idx]);
+		config->paths[path_idx] = NULL;
+	}
 	return ret;
 }
 
@@ -673,6 +722,7 @@ int parse_config_arguments(struct mako_config *config, int argc, char **argv) {
 		{"anchor", required_argument, 0, 0},
 		{"sort", required_argument, 0, 0},
 		{"group-by", required_argument, 0, 0},
+		{"include", required_argument, 0, 0},
 		{0},
 	};
 
diff --git a/include/config.h b/include/config.h
index a3abc9c..aa42bdd 100644
--- a/include/config.h
+++ b/include/config.h
@@ -85,6 +85,8 @@ struct mako_config {
 	} button_bindings;
 
 	enum mako_binding touch;
+
+	char **paths; // array of all loaded configs
 };
 
 void init_default_config(struct mako_config *config);
